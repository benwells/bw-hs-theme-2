{"version":3,"file":"each.js","sources":["../../../node_modules/svelte/src/internal/client/dom/blocks/each.js"],"sourcesContent":["/** @import { EachItem, EachOutroGroup, EachState, Effect, EffectNodes, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\n/** @import { Batch } from '../../reactivity/batch.js'; */\nimport {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_ITEM_IMMUTABLE,\n\tEACH_ITEM_REACTIVE,\n\tHYDRATION_END,\n\tHYDRATION_START_ELSE\n} from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tread_hydration_instruction,\n\tskip_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling,\n\tshould_defer_append\n} from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\nimport { array_from, is_array } from '../../../shared/utils.js';\nimport { BRANCH_EFFECT, COMMENT_NODE, EFFECT_OFFSCREEN, INERT } from '#client/constants';\nimport { queue_micro_task } from '../task.js';\nimport { get } from '../../runtime.js';\nimport { DEV } from 'esm-env';\nimport { derived_safe_equal } from '../../reactivity/deriveds.js';\nimport { current_batch } from '../../reactivity/batch.js';\n\n// When making substantive changes to this file, validate them with the each block stress test:\n// https://svelte.dev/playground/1972b2cf46564476ad8c8c6405b23b7b\n// This test also exists in this repo, as `packages/svelte/tests/manual/each-stress-test`\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {EachState} state\n * @param {Effect[]} to_destroy\n * @param {null | Node} controlled_anchor\n */\nfunction pause_effects(state, to_destroy, controlled_anchor) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = to_destroy.length;\n\n\t/** @type {EachOutroGroup} */\n\tvar group;\n\tvar remaining = to_destroy.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tlet effect = to_destroy[i];\n\n\t\tpause_effect(\n\t\t\teffect,\n\t\t\t() => {\n\t\t\t\tif (group) {\n\t\t\t\t\tgroup.pending.delete(effect);\n\t\t\t\t\tgroup.done.add(effect);\n\n\t\t\t\t\tif (group.pending.size === 0) {\n\t\t\t\t\t\tvar groups = /** @type {Set<EachOutroGroup>} */ (state.outrogroups);\n\n\t\t\t\t\t\tdestroy_effects(array_from(group.done));\n\t\t\t\t\t\tgroups.delete(group);\n\n\t\t\t\t\t\tif (groups.size === 0) {\n\t\t\t\t\t\t\tstate.outrogroups = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tremaining -= 1;\n\t\t\t\t}\n\t\t\t},\n\t\t\tfalse\n\t\t);\n\t}\n\n\tif (remaining === 0) {\n\t\t// If we're in a controlled each block (i.e. the block is the only child of an\n\t\t// element), and we are removing all items, _and_ there are no out transitions,\n\t\t// we can use the fast path — emptying the element and replacing the anchor\n\t\tvar fast_path = transitions.length === 0 && controlled_anchor !== null;\n\n\t\tif (fast_path) {\n\t\t\tvar anchor = /** @type {Element} */ (controlled_anchor);\n\t\t\tvar parent_node = /** @type {Element} */ (anchor.parentNode);\n\n\t\t\tclear_text_content(parent_node);\n\t\t\tparent_node.append(anchor);\n\n\t\t\tstate.items.clear();\n\t\t}\n\n\t\tdestroy_effects(to_destroy, !fast_path);\n\t} else {\n\t\tgroup = {\n\t\t\tpending: new Set(to_destroy),\n\t\t\tdone: new Set()\n\t\t};\n\n\t\t(state.outrogroups ??= new Set()).add(group);\n\t}\n}\n\n/**\n * @param {Effect[]} to_destroy\n * @param {boolean} remove_dom\n */\nfunction destroy_effects(to_destroy, remove_dom = true) {\n\t// TODO only destroy effects if no pending batch needs them. otherwise,\n\t// just re-add the `EFFECT_OFFSCREEN` flag\n\tfor (var i = 0; i < to_destroy.length; i++) {\n\t\tdestroy_effect(to_destroy[i], remove_dom);\n\t}\n}\n\n/** @type {TemplateNode} */\nvar offscreen_anchor;\n\n/**\n * @template V\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\tvar anchor = node;\n\n\t/** @type {Map<any, EachItem>} */\n\tvar items = new Map();\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (node);\n\n\t\tanchor = hydrating\n\t\t\t? set_hydrate_node(get_first_child(parent_node))\n\t\t\t: parent_node.appendChild(create_text());\n\t}\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\t/** @type {Effect | null} */\n\tvar fallback = null;\n\n\t// TODO: ideally we could use derived for runes mode but because of the ability\n\t// to use a store which can be mutated, we can't do that here as mutating a store\n\t// will still result in the collection array being the same from the store\n\tvar each_array = derived_safe_equal(() => {\n\t\tvar collection = get_collection();\n\n\t\treturn is_array(collection) ? collection : collection == null ? [] : array_from(collection);\n\t});\n\n\t/** @type {V[]} */\n\tvar array;\n\n\tvar first_run = true;\n\n\tfunction commit() {\n\t\tstate.fallback = fallback;\n\t\treconcile(state, array, anchor, flags, get_key);\n\n\t\tif (fallback !== null) {\n\t\t\tif (array.length === 0) {\n\t\t\t\tif ((fallback.f & EFFECT_OFFSCREEN) === 0) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback.f ^= EFFECT_OFFSCREEN;\n\t\t\t\t\tmove(fallback, null, anchor);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\t// TODO only null out if no pending batch needs it,\n\t\t\t\t\t// otherwise re-add `fallback.fragment` and move the\n\t\t\t\t\t// effect into it\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tvar effect = block(() => {\n\t\tarray = /** @type {V[]} */ (get(each_array));\n\t\tvar length = array.length;\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;\n\n\t\t\tif (is_else !== (length === 0)) {\n\t\t\t\t// hydration mismatch — remove the server-rendered DOM and start over\n\t\t\t\tanchor = skip_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\tvar keys = new Set();\n\t\tvar batch = /** @type {Batch} */ (current_batch);\n\t\tvar defer = should_defer_append();\n\n\t\tfor (var index = 0; index < length; index += 1) {\n\t\t\tif (\n\t\t\t\thydrating &&\n\t\t\t\thydrate_node.nodeType === COMMENT_NODE &&\n\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\n\t\t\t) {\n\t\t\t\t// The server rendered fewer items than expected,\n\t\t\t\t// so break out and continue appending non-hydrated items\n\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\n\t\t\t\tmismatch = true;\n\t\t\t\tset_hydrating(false);\n\t\t\t}\n\n\t\t\tvar value = array[index];\n\t\t\tvar key = get_key(value, index);\n\n\t\t\tvar item = first_run ? null : items.get(key);\n\n\t\t\tif (item) {\n\t\t\t\t// update before reconciliation, to trigger any async updates\n\t\t\t\tif (item.v) internal_set(item.v, value);\n\t\t\t\tif (item.i) internal_set(item.i, index);\n\n\t\t\t\tif (defer) {\n\t\t\t\t\tbatch.skipped_effects.delete(item.e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\titem = create_item(\n\t\t\t\t\titems,\n\t\t\t\t\tfirst_run ? anchor : (offscreen_anchor ??= create_text()),\n\t\t\t\t\tvalue,\n\t\t\t\t\tkey,\n\t\t\t\t\tindex,\n\t\t\t\t\trender_fn,\n\t\t\t\t\tflags,\n\t\t\t\t\tget_collection\n\t\t\t\t);\n\n\t\t\t\tif (!first_run) {\n\t\t\t\t\titem.e.f |= EFFECT_OFFSCREEN;\n\t\t\t\t}\n\n\t\t\t\titems.set(key, item);\n\t\t\t}\n\n\t\t\tkeys.add(key);\n\t\t}\n\n\t\tif (length === 0 && fallback_fn && !fallback) {\n\t\t\tif (first_run) {\n\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t} else {\n\t\t\t\tfallback = branch(() => fallback_fn((offscreen_anchor ??= create_text())));\n\t\t\t\tfallback.f |= EFFECT_OFFSCREEN;\n\t\t\t}\n\t\t}\n\n\t\t// remove excess nodes\n\t\tif (hydrating && length > 0) {\n\t\t\tset_hydrate_node(skip_nodes());\n\t\t}\n\n\t\tif (!first_run) {\n\t\t\tif (defer) {\n\t\t\t\tfor (const [key, item] of items) {\n\t\t\t\t\tif (!keys.has(key)) {\n\t\t\t\t\t\tbatch.skipped_effects.add(item.e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbatch.oncommit(commit);\n\t\t\t\tbatch.ondiscard(() => {\n\t\t\t\t\t// TODO presumably we need to do something here?\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcommit();\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// When we mount the each block for the first time, the collection won't be\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\n\t\t// will now be `CLEAN`.\n\t\tget(each_array);\n\t});\n\n\t/** @type {EachState} */\n\tvar state = { effect, flags, items, outrogroups: null, fallback };\n\n\tfirst_run = false;\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * Skip past any non-branch effects (which could be created with `createSubscriber`, for example) to find the next branch effect\n * @param {Effect | null} effect\n * @returns {Effect | null}\n */\nfunction skip_to_branch(effect) {\n\twhile (effect !== null && (effect.f & BRANCH_EFFECT) === 0) {\n\t\teffect = effect.next;\n\t}\n\treturn effect;\n}\n\n/**\n * Add, remove, or reorder items output by an each block as its input changes\n * @template V\n * @param {EachState} state\n * @param {Array<V>} array\n * @param {Element | Comment | Text} anchor\n * @param {number} flags\n * @param {(value: V, index: number) => any} get_key\n * @returns {void}\n */\nfunction reconcile(state, array, anchor, flags, get_key) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar current = skip_to_branch(state.effect.first);\n\n\t/** @type {undefined | Set<Effect>} */\n\tvar seen;\n\n\t/** @type {Effect | null} */\n\tvar prev = null;\n\n\t/** @type {undefined | Set<Effect>} */\n\tvar to_animate;\n\n\t/** @type {Effect[]} */\n\tvar matched = [];\n\n\t/** @type {Effect[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {Effect | undefined} */\n\tvar effect;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\teffect = /** @type {EachItem} */ (items.get(key)).e;\n\n\t\t\t// offscreen == coming in now, no animation in that case,\n\t\t\t// else this would happen https://github.com/sveltejs/svelte/issues/17181\n\t\t\tif ((effect.f & EFFECT_OFFSCREEN) === 0) {\n\t\t\t\teffect.nodes?.a?.measure();\n\t\t\t\t(to_animate ??= new Set()).add(effect);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\n\t\teffect = /** @type {EachItem} */ (items.get(key)).e;\n\n\t\tif (state.outrogroups !== null) {\n\t\t\tfor (const group of state.outrogroups) {\n\t\t\t\tgroup.pending.delete(effect);\n\t\t\t\tgroup.done.delete(effect);\n\t\t\t}\n\t\t}\n\n\t\tif ((effect.f & EFFECT_OFFSCREEN) !== 0) {\n\t\t\teffect.f ^= EFFECT_OFFSCREEN;\n\n\t\t\tif (effect === current) {\n\t\t\t\tmove(effect, null, anchor);\n\t\t\t} else {\n\t\t\t\tvar next = prev ? prev.next : current;\n\n\t\t\t\tif (effect === state.effect.last) {\n\t\t\t\t\tstate.effect.last = effect.prev;\n\t\t\t\t}\n\n\t\t\t\tif (effect.prev) effect.prev.next = effect.next;\n\t\t\t\tif (effect.next) effect.next.prev = effect.prev;\n\t\t\t\tlink(state, prev, effect);\n\t\t\t\tlink(state, effect, next);\n\n\t\t\t\tmove(effect, next, anchor);\n\t\t\t\tprev = effect;\n\n\t\t\t\tmatched = [];\n\t\t\t\tstashed = [];\n\n\t\t\t\tcurrent = skip_to_branch(prev.next);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif ((effect.f & INERT) !== 0) {\n\t\t\tresume_effect(effect);\n\t\t\tif (is_animated) {\n\t\t\t\teffect.nodes?.a?.unfix();\n\t\t\t\t(to_animate ??= new Set()).delete(effect);\n\t\t\t}\n\t\t}\n\n\t\tif (effect !== current) {\n\t\t\tif (seen !== undefined && seen.has(effect)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(state, a.prev, b.next);\n\t\t\t\t\tlink(state, prev, a);\n\t\t\t\t\tlink(state, b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(effect);\n\t\t\t\t\tmove(effect, current, anchor);\n\n\t\t\t\t\tlink(state, effect.prev, effect.next);\n\t\t\t\t\tlink(state, effect, prev === null ? state.effect.first : prev.next);\n\t\t\t\t\tlink(state, prev, effect);\n\n\t\t\t\t\tprev = effect;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current !== effect) {\n\t\t\t\t(seen ??= new Set()).add(current);\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = skip_to_branch(current.next);\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif ((effect.f & EFFECT_OFFSCREEN) === 0) {\n\t\t\tmatched.push(effect);\n\t\t}\n\n\t\tprev = effect;\n\t\tcurrent = skip_to_branch(effect.next);\n\t}\n\n\tif (state.outrogroups !== null) {\n\t\tfor (const group of state.outrogroups) {\n\t\t\tif (group.pending.size === 0) {\n\t\t\t\tdestroy_effects(array_from(group.done));\n\t\t\t\tstate.outrogroups?.delete(group);\n\t\t\t}\n\t\t}\n\n\t\tif (state.outrogroups.size === 0) {\n\t\t\tstate.outrogroups = null;\n\t\t}\n\t}\n\n\tif (current !== null || seen !== undefined) {\n\t\t/** @type {Effect[]} */\n\t\tvar to_destroy = [];\n\n\t\tif (seen !== undefined) {\n\t\t\tfor (effect of seen) {\n\t\t\t\tif ((effect.f & INERT) === 0) {\n\t\t\t\t\tto_destroy.push(effect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (current !== null) {\n\t\t\t// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished\n\t\t\tif ((current.f & INERT) === 0 && current !== state.fallback) {\n\t\t\t\tto_destroy.push(current);\n\t\t\t}\n\n\t\t\tcurrent = skip_to_branch(current.next);\n\t\t}\n\n\t\tvar destroy_length = to_destroy.length;\n\n\t\tif (destroy_length > 0) {\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\t\tif (is_animated) {\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].nodes?.a?.measure();\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].nodes?.a?.fix();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpause_effects(state, to_destroy, controlled_anchor);\n\t\t}\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (to_animate === undefined) return;\n\t\t\tfor (effect of to_animate) {\n\t\t\t\teffect.nodes?.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @template V\n * @param {Map<any, EachItem>} items\n * @param {Node} anchor\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @returns {EachItem}\n */\nfunction create_item(items, anchor, value, key, index, render_fn, flags, get_collection) {\n\tvar v =\n\t\t(flags & EACH_ITEM_REACTIVE) !== 0\n\t\t\t? (flags & EACH_ITEM_IMMUTABLE) === 0\n\t\t\t\t? mutable_source(value, false, false)\n\t\t\t\t: source(value)\n\t\t\t: null;\n\n\tvar i = (flags & EACH_INDEX_REACTIVE) !== 0 ? source(index) : null;\n\n\tif (DEV && v) {\n\t\t// For tracing purposes, we need to link the source signal we create with the\n\t\t// collection + index so that tracing works as intended\n\t\tv.trace = () => {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\t\t\tget_collection()[i?.v ?? index];\n\t\t};\n\t}\n\n\treturn {\n\t\tv,\n\t\ti,\n\t\te: branch(() => {\n\t\t\trender_fn(anchor, v ?? value, i ?? index, get_collection);\n\n\t\t\treturn () => {\n\t\t\t\titems.delete(key);\n\t\t\t};\n\t\t})\n\t};\n}\n\n/**\n * @param {Effect} effect\n * @param {Effect | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(effect, next, anchor) {\n\tif (!effect.nodes) return;\n\n\tvar node = effect.nodes.start;\n\tvar end = effect.nodes.end;\n\n\tvar dest =\n\t\tnext && (next.f & EFFECT_OFFSCREEN) === 0\n\t\t\t? /** @type {EffectNodes} */ (next.nodes).start\n\t\t\t: anchor;\n\n\twhile (node !== null) {\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tdest.before(node);\n\n\t\tif (node === end) {\n\t\t\treturn;\n\t\t}\n\n\t\tnode = next_node;\n\t}\n}\n\n/**\n * @param {EachState} state\n * @param {Effect | null} prev\n * @param {Effect | null} next\n */\nfunction link(state, prev, next) {\n\tif (prev === null) {\n\t\tstate.effect.first = next;\n\t} else {\n\t\tprev.next = next;\n\t}\n\n\tif (next === null) {\n\t\tstate.effect.last = prev;\n\t} else {\n\t\tnext.prev = prev;\n\t}\n}\n"],"names":["index","key","item"],"mappings":"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","x_google_ignoreList":[0]}